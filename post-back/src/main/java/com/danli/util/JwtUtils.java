
package com.danli.util;
/**
 * @author: mingyu.Jin
 * @date: 2022/4/11
 */
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;


@Slf4j
@Data
@Component
@ConfigurationProperties(prefix = "fanli.jwt")
public class JwtUtils {

    private String secret;
    private long expire;
    private String header;

    /**
     * generate JWT Token string

     * @param userId
     * expireDate
     * claims
     *For example, you can add user name, user ID, user (before encryption) password and other information
     */
    public String generateToken(long userId,String username) {
        Date nowDate = new Date();
        //过期时间
        Date expireDate = new Date(nowDate.getTime() + expire * 1000);
        Map<String, Object> claims = new HashMap<String, Object>();//Create a private declaration of payload (add it according to specific business needs. If you want to use this for verification, you generally need to communicate the verification method with the receiver of JWT in advance)
        claims.put("userId", userId+"");
        claims.put("username", username);
        return Jwts.builder()    //
                .setHeaderParam("typ", "JWT")  //set
                .setClaims(claims)
                .setIssuedAt(nowDate)        //payload nowdate
                .setExpiration(expireDate)   //payload expire data
                .signWith(SignatureAlgorithm.HS512, secret)  // set secret passport
                .compact();            //generate token 1. Header and  Payload
    }
    /**
     *  token
     * JWT Token It consists of three parts: the head part and the load part. The signature part is generated by the encryption algorithm and cannot be decrypted in reverse.
     * The head and load parts are generated by Base64 coding algorithm, which can be reverse encoded back to the original.
     * This is why you should not put sensitive data in JWT token.
     *
     * @param token
     * @return claims Returns the key value pair of the load part
     */
    public Claims getClaimByToken(String token) {
        try {
            return Jwts.parser()
                    .setSigningKey(secret)
                    .parseClaimsJws(token)
                    .getBody();     // get payload some content
        } catch (Exception e) {
            log.debug("validate is token error ", e);
            return null;
        }
    }


    public boolean isTokenExpired(Date expiration) {
        return expiration.before(new Date());
    }
}
